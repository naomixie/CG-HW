# CG Homework 2

计算机图形学第二次作业报告，作业环境基于助教提供的第一次作业文件包。

exe 文件全部在/Release 目录下，并且按顺序分别为第一，二，三小题。
源代码则放在了/code 目录下。

为了次作业内容进行的具体工作有：

- 研究在 openGL 中以像素单位进行绘图的实现
- 研究扫描线算法的具体实现
- 在第三题中运用了类似分治法的算法

## 目录

- [扫描线算法实现](#扫描线算法实现)
  - [数据结构](#数据结构)
  - [重叠显示](#重叠显示)
  - [渐变色实现](#渐变色实现)
- [分治算法实现](#分治算法实现)

## 扫描线算法实现

这一章节将说明在第一第二题中使用扫描线算法进行绘图的具体实现方式。

### 数据结构

本次项目中我为了实现扫描线算法主要是选择了以边为抽象主体设计数据结构，该结构参考了书中第 4.6 节中的内容。参考过后我选择了在边类里面储存其顶点的相关信息以及计算其每个而二维平面上的斜率（用于后面计算），除此之外为了实现渐变色的效果，我还将该边的对面的顶点的数据储存在里面，其中包括该点的位置信息与 rgb 值，用于计算该对角顶点对后期扫描时的每个像素的权值影响（具体计算方法在[分治算法实现](#分治算法实现)中进行说明）。

    边类:

    数据：
    - 两个端点位置信息
    - 三个二维平面上的斜率与截距
    - id用于记录该点属于哪个三角形（按照txt文件中的行数来确定，从上到下为0，1，2，3）
    - 对角顶点的位置信息和该点的rgb值

    函数：
    - 用y值计算该边上交点的x值
    - 用y值计算该边上交点的z值
    - 用x，y值计算该边的对角顶点对该位置像素点的加权影响

当检测到一个区间为两个区间的交集时，我们会检测其深度来选择颜色，而为了获得某个特定的点的深度，我们需要一个用扫描线的 y 值来获取该点的深度。

而为了获取这样的一条直线，我们需要的是当前扫描线的两个交点的 x，z 值，并计算该线的函数，并用于计算该区间内的所有像素的深度值，因此设计了切线类来实现这一功能。

    - 切线类

    数据：

    - 切线的两个顶点位置
    - 切线函数的斜率与截距

    函数：

    - 用x值计算深度的函数

除此之外还用到了一个区间类用于记录扫描线在扫描时扫描到的各个区间。

    - 区间类

    数据：

    - info：
        - 最小值最大值的x，z值
        - 与边类相同的id
    - 一个切线类变量

最后还有一个边表，用一个边类的数组表示，以及一个活边表在每一次扫描时生成，是一个边表为 Template 的 List。

为了加快扫描的速度，还在读入数据的时候边记录了整张图的扫描范围，即其最小最大 x，y 值，在扫描时可以略过一部份区域。

### 重叠显示

扫描线算法逻辑储存在 fill（）函数内，大致流程为：

- 读取数据阶段：
  - 将数据存进一个二维数组里，并且同时使用读到的数据来生成相应的边类，用 id 来记录他们属于哪个三角形
  - 将新生成的边类“登记”在边表中
  - 同时记录绘画范围

#### 开始扫描：

- 找相交的边：
  - 首先生成活边表来记录扫描线扫描到的绘图区域
  - 循环边表中的所有边，用边类中记录的 y 值范围来判断该线段与扫描线是否相交。
    - 如果相交则将该边加入活边表中
- 生成与三角形相交的区域的区间：
  - 直到活边表为空，一直循环并找出两两属于同一三角形的边
  - 判断条件为两条边的 id 值
  - 如果两边匹配成功，则生成一个区间类记录需要涂色的区间，并将两边从活边表中删除
- 首先遍历一次所有的区间，并对区间的像素进行涂色
- 解决相交区间：
  - 对所有区间进行两两对比
  - 如果区间有交集，则将两个区间按照大小范围分成三个子区间，并对其分别进行涂色
    - 对第一个跟第三个区间：按照该区间属于的三角形颜色进行涂色
    - 对于中间有冲突的区间，则需要对其进行深度检测，判断其颜色
      - 使用两个区间类内已有的切线类变量的函数来计算该区间内每个像素的深度，并对该深度进行对比，取深度较大的区间的三角形颜色。
  - 如果两个区间完全重合，则直接使用上面的深度检测进行涂色
- 继续扫描直到达到屏幕的长度

### 渐变色实现

渐变色的实现逻辑是使用了数学中的相似三角形与截距的知识。

首先观察图像我发现作业图像中的图我发现该图像中的三种颜色渐变色在边界似乎是呈直线状的，又因为三个顶点只在 rgb 三个值中对一个值产生影响，所以我分析出来三角形中像素的 rgb 三个值应该是与其到三个顶点对面的边的距离呈反比的。也就是说，该点距离对面边的距离越近，其收到顶点颜色的影响越少，同时也满足了以平行于对边颜色渐变的需求。

由此我们可以得出一下的结论，并且只要对该像素属于的三角形的所有边进行相应的计算，将其结果累加起来便是像素点的 rgb 值。

![r1](./pics/r1.png)

然而由于点到对边的距离，以及顶点到对边的距离比较难以计算，因此我想到了运用相似三角形的三条边的比值相同的方法，用两个截距的壁纸来替代两个距离的比值进行计算。

![r1](./pics/r2.png)

由于距离与另一条边与底边（这条边为已知边，计算的是他的对顶点的 rgb 影响）形成两个相似三角形，因此距离值之比就等于两个三角形的两个边之比。用底边的斜率去生成经过像素点与对顶点的两条平行线在 x 上的截距，用边的截距分别减去生成的两个截距，再将其相除得出比值，该比值便是对顶点对于该像素的 rgb 影响的一个比值。

## 分治算法实现

在这里将对第三题中分治算法的实现进行详细说明。

首先观察图像可以发现该图有很高的重复性，其中可以从中间分成四个相同的子区域。
再进一步观察子区域可以发现它也可以从中间分成四个两两相等的子区域。

![r1](./pics/r3.png)

由此想到了了使用分治法实现。

我们将整个图以一个 4\*4 的规模去看的话（以红绿色块为基本单位），对于子子色块我们发现红色区块总是在 x 与 y 值相加为偶数的时候发生的，而绿色区块则是总和为单数的时候发生的，由此我们可以在绘制的时候通过判断其综合来判定需要绘制的子子色块是哪一种色块。

由于四个蓝色区块相互之间没有任何不同，我们实际上在绘制一个蓝色区块时可以同时绘制其他所有蓝色区块的相应位置，这样可以减少不必要的循环。

由此可以得出逻辑：

    - 选择一个子区块（蓝色），对其进行涂色
        - 分析该像素位于相对于这一子区块来说位于哪一个子子区块（红绿色），运用之前提到的总和为单数还是偶数
            - 如果为偶数则在所有蓝色区块的相应位置绘制红色区块
            - 如果为单数则绘所有蓝色区块的相应位置制绿色区块

最后得到目标图像。
