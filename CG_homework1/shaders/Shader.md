# Shaders

从基本意义上来说，着色器只是一种把输入转化为输出的程序。

## GLSL

着色器是使用一种叫 GLSL 的类 C 语言写成的。GLSL 是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。

        #version version_number             //着色器的开头总是要声明版本
        in type in_variable_name;           //输入 变量
        in type in_variable_name;           //每个输入变量也叫顶点属性

        out type out_variable_name;         //输出变量

        uniform type uniform_name;          //uniform 函数

        // main函数，每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，
        // 并将结果输出到输出变量中。
        int main()
        {
        // 处理输入并进行一些图形操作
        ...
        // 输出处理过的结果到输出变量
        out_variable_name = weird_stuff_we_processed;
        }

我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL 确保至少有 16 个包含 4 分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询 GL_MAX_VERTEX_ATTRIBS 来获取具体的上限：

        int nrAttributes;
        glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
        std::cout << "Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;

通常情况下它至少会返回 16 个，大部分情况下是够用了。

## 数据类型

和其他编程语言一样，GLSL 有数据类型可以来指定变量的种类。GLSL 中包含 C 等其它语言大部分的默认基础数据类型：int、float、double、uint 和 bool。GLSL 也有两种容器类型，它们会在这个教程中使用很多，分别是向量(Vector)和矩阵(Matrix)，其中矩阵我们会在之后的教程里再讨论。

### 向量

GLSL 中的向量是一个可以包含有 1、2、3 或者 4 个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n 代表分量的数量）：

- vecn 包含 n 个 float 分量的默认向量
- bvecn 包含 n 个 bool 分量的向量
- ivecn 包含 n 个 int 分量的向量
- uvecn 包含 n 个 unsigned int 分量的向量
- dvecn 包含 n 个 double 分量的向量

大多数时候我们使用 vecn，因为 float 足够满足大多数要求了。

一个向量的分量可以通过 vec.x 这种方式获取，这里 x 是指这个向量的第一个分量。你可以分别使用.x、.y、.z 和.w 来获取它们的第 1、2、3、4 个分量。GLSL 也允许你对颜色使用 rgba，或是对纹理坐标使用 stpq 访问相同的分量。

### 顶点着色器

顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代 OpenGL 需要我们至少设置一个顶点和一个片段着色器。我们会简要介绍一下着色器以及配置两个非常简单的着色器来绘制我们第一个三角形。下一节中我们会更详细的讨论着色器。

我们需要做的第一件事是用着色器语言 GLSL(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的 GLSL 顶点着色器的源代码：

        #version 330 core
        layout (location = 0) in vec3 aPos;

        void main()
        {
            gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
        }

可以看到，GLSL 看起来很像 C 语言。每个着色器都起始于一个版本声明。OpenGL 3.3 以及和更高版本中，GLSL 版本号和 OpenGL 的版本是匹配的（比如说 GLSL 420 版本对应于 OpenGL 4.2）。我们同样明确表示我们会使用核心模式。

下一步，使用 in 关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL 有一个向量数据类型，它包含 1 到 4 个 float 分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个 3D 坐标，我们就创建一个 vec3 输入变量 aPos。我们同样也通过 layout (location = 0)设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。

为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 gl_Position 变量，它在幕后是 vec4 类型的。在 main 函数的最后，我们将 gl_Position 设置的值会成为该顶点着色器的输出。由于我们的输入是一个 3 分量的向量，我们必须把它转换为 4 分量的。我们可以把 vec3 的数据作为 vec4 构造器的参数，同时把 w 分量设置为 1.0f（我们会在后面解释为什么）来完成这一任务。

当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内。

### 编译着色器

我们已经写了一个顶点着色器源码（储存在一个 C 的字符串中），但是为了能够让 OpenGL 使用它，我们必须在运行时动态编译它的源码。

我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的。所以我们储存这个顶点着色器为 unsigned int，然后用 glCreateShader 创建这个着色器：

### 片段着色器

片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。

    在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！

### 输入与输出

虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL 定义了 in 和 out 关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，_只要一个输出变量与下一个着色器阶段的输入匹配_，它就会传递下去。但在顶点和片段着色器中会有点不同。

顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。
为了定义顶点数据该如何管理，我们使用 location 这一元数据指定输入变量，这样我们才可以在 CPU 上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的 layout 标识，这样我们才能把它链接到顶点数据。
